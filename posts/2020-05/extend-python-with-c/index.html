<!DOCTYPE html>
<html lang="zh_cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>用 C 语言扩展 Python | ZomHub</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="zh_cn" href="../../../rss.xml">
<link rel="canonical" href="https://blog.zombie110year.top/posts/2020-05/extend-python-with-c/">
<link rel="icon" href="../../../favicon.ico" sizes="256x256">
<link rel="icon" href="../../../favicon.png" sizes="512x512">
<meta name="author" content="Zombie110year">
<link rel="prev" href="../numeric-caculate-regression-analysis/" title="数值计算：回归分析" type="text/html">
<link rel="next" href="../../2020-06/parallel-job-in-powershell/" title="在 PowerShell 中并行执行任务" type="text/html">
<meta property="og:site_name" content="ZomHub">
<meta property="og:title" content="用 C 语言扩展 Python">
<meta property="og:url" content="https://blog.zombie110year.top/posts/2020-05/extend-python-with-c/">
<meta property="og:description" content="Python 官方给出教程如下 1，本文总结几个要点，并介绍与 Python Poetry 2 工具相结合的方法。

目录

文件安排与开发前的准备
自顶向下的教程

初始化模块
试运行
解析位置参数
通过 Iterator Protocol 解析不定参数
解析关键字参数


Python 与 C 对象的互相转化
将扩展编译过程集成到 poetry build
添加类型定义
参考链接




文件">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-05-30T15:00:48+08:00">
<meta property="article:tag" content="c">
<meta property="article:tag" content="python">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">跳到主内容</a>
    <div id="container">
            <header id="header"><h1 id="brand"><a href="https://blog.zombie110year.top/" title="ZomHub" rel="home">

        <span id="blog-title">ZomHub</span>
    </a></h1>

        
            <nav id="menu"><ul>
<li><a href="../../../archive.html">归档</a></li>
                <li><a href="../../../categories/">标签</a></li>
                <li><a href="../../../rss.xml">订阅</a></li>

    
    
    
    </ul></nav></header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">用 C 语言扩展 Python</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Zombie110year
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2020-05-30T15:00:48+08:00" itemprop="datePublished" title="2020-05-30 15:00">2020-05-30 15:00</time></a>
            </p>
                    <p class="sourceline"><a href="index.rst" class="sourcelink">源文件</a></p>

        </div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>Python 官方给出教程如下 <a class="footnote-reference brackets" href="#doc-ext" id="id1">1</a>，本文总结几个要点，并介绍与 Python Poetry <a class="footnote-reference brackets" href="#site-poetry" id="id2">2</a> 工具相结合的方法。</p>
<div class="contents topic" id="id3">
<p class="topic-title">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id4" id="id15">文件安排与开发前的准备</a></p></li>
<li>
<p><a class="reference internal" href="#id6" id="id16">自顶向下的教程</a></p>
<ul>
<li><p><a class="reference internal" href="#id7" id="id17">初始化模块</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id18">试运行</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id19">解析位置参数</a></p></li>
<li><p><a class="reference internal" href="#iterator-protocol" id="id20">通过 Iterator Protocol 解析不定参数</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id21">解析关键字参数</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#python-c" id="id22">Python 与 C 对象的互相转化</a></p></li>
<li><p><a class="reference internal" href="#poetry-build" id="id23">将扩展编译过程集成到 poetry build</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id24">添加类型定义</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id25">参考链接</a></p></li>
</ul>
</div>
<!-- TEASER_END -->
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id15">文件安排与开发前的准备</a></h2>
<p>对于一个包含 C 扩展的 Python 模块，我们期望它如同一个标准的纯 Python 包那样使用，
可以将文件系统如下布置，<code class="docutils literal">/</code> 表示当前工作目录，假设我们的包叫做 spam:</p>
<pre class="literal-block">/
    pyproject.toml          poetry 创建的项目元数据文件
    build.py                构建脚本
    spam                    包
        __init__.py         封装 Python 接口
        spam_.c             一般在扩展模块名后加 _，而通过同名 Python 模块向外导出接口
        &lt;spam_.pyd&gt;         编译后，期望二进制模块位于此处</pre>
<p>如果使用 Linux 系统，那么在安装 Python 时，其必要的库文件与头文件已经在编译器的检索路径中了；
如果使用 Windows 系统，那么在开发时，还需要设置开发工具的头文件检索路径，将 Python.h 所在的路径添加到其中，
例如 Vscode 的 C++ 设置：</p>
<pre class="code json"><a name="rest_code_7066c53b81a3429a8ac934b40aa3887d-1"></a><span class="s2">"${env:USERPROFILE}/scoop/apps/python/3.8.2/include/**"</span>
</pre>
<p>这里笔者在 Windows 上使用了 <em>scoop</em> <a class="footnote-reference brackets" href="#site-scoop" id="id5">3</a> 来安装 Python，因此安装路径如上。
不过不需要另外配置，这里只是让语言服务器能够找到符号而已，在编译时，通过 Python 提供的 disutils 模块，
它可以自己找到自己。</p>
<p>注意，由于 MSVC 和 GCC ABI 不同，在 Windows 上编译 Python C 扩展需要 Visual Studio C++ 开发负载安装。
（因为 Windows 上的 Python 发行版是 MSVC 编译的）
记得勾选 Windows 10 SDK，尽管它体积庞大，令人生厌，但它是在 Windows 10 上编译 Python C 扩展的必要组件。</p>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id16">自顶向下的教程</a></h2>
<p>Python 官方教程选择了从细节到整体的讲解路线，本文则先说明如何创建一个模块，然后添加另外的成分。</p>
<p>注意，由于 Python.h 通过宏来对跨平台代码进行一些设置，因此这个头文件应当第一个被包含。并且在它之前用 <code class="docutils literal">#define PY_SSIZE_T_CLEAN</code> 设置 Python 相关方法使用 <code class="docutils literal">Py_ssize_t</code> 来代替 int 作为尺寸类型。</p>
<pre class="code c"><a name="rest_code_9fef055c9f02482cb24dd5682b473e8a-1"></a><span class="cp">#define PY_SSIZE_T_CLEAN</span>
<a name="rest_code_9fef055c9f02482cb24dd5682b473e8a-2"></a><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>
</pre>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id17">初始化模块</a></h3>
<p>一个 Python 模块是一个 <strong>模块定义结构体</strong> ，这个结构体有一个重要成员名为 <strong>模块方法表</strong> ，
所有模块中提供的方法都必须在模块方法表中导出。
而模块定义结构体也必须被模块初始化函数导出。</p>
<p>模块方法表是一个数组，定义了该模块所导出的方法（函数），其元素为一个结构体，具有四个字段，按顺序分别为：</p>
<dl>
<dt>方法名（const char*）</dt>
<dd>
<p>该方法在 Python 中使用的命名；</p>
</dd>
<dt>函数指针</dt>
<dd>
<p>该方法在 C 中的实例；</p>
</dd>
<dt>传参机制</dt>
<dd>
<p>传入在 Python.h 中预定义的 bitflag，可选值有：</p>
<dl class="simple">
<dt><code>METH_VARARGS</code></dt>
<dd>
<p>表示接受一个 tuple 为参数</p>
</dd>
<dt><code>METH_VARARGS | METH_KEYWORDS</code></dt>
<dd>
<p>表示既接受元组，也接受关键字参数，这种情况下，一个导出给 Python 使用的函数需要接受第三个 PyObject* 作为参数，
传入一个字典。</p>
</dd>
</dl>
</dd>
<dt>文档字符串（const char*）</dt>
<dd>
<p>该方法的文档字符串。
一般留 NULL，而在对应的 pyi 文件中编写文档字符串，因为这种东西一般由开发工具使用，运行时不会管它。
除非该模块需要利用 docstring 实现特殊功能。</p>
</dd>
</dl>
<p>例如：</p>
<pre class="code c"><a name="rest_code_83e6698901e24232b0cb083d6c669fc8-1"></a><span class="c1">/// 将所有传入参数加到一起</span>
<a name="rest_code_83e6698901e24232b0cb083d6c669fc8-2"></a><span class="n">PyObject</span> <span class="o">*</span><span class="nf">add</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<a name="rest_code_83e6698901e24232b0cb083d6c669fc8-3"></a>
<a name="rest_code_83e6698901e24232b0cb083d6c669fc8-4"></a><span class="c1">/// 模块方法表</span>
<a name="rest_code_83e6698901e24232b0cb083d6c669fc8-5"></a><span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">SPAM_METHODS</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<a name="rest_code_83e6698901e24232b0cb083d6c669fc8-6"></a>    <span class="p">{</span><span class="s">"add"</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">},</span>
<a name="rest_code_83e6698901e24232b0cb083d6c669fc8-7"></a><span class="p">};</span>
</pre>
<p>模块定义结构和模块方法表中的元素其实是同一种类型，只不过多一个初始化字段：</p>
<pre class="code c"><a name="rest_code_31b1067925774b9fa19b5af40f9992a3-1"></a><span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">SPAM_MOD</span> <span class="o">=</span> <span class="p">{</span>
<a name="rest_code_31b1067925774b9fa19b5af40f9992a3-2"></a>    <span class="c1">/// 模块初始化基对象</span>
<a name="rest_code_31b1067925774b9fa19b5af40f9992a3-3"></a>    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
<a name="rest_code_31b1067925774b9fa19b5af40f9992a3-4"></a>    <span class="c1">/// 模块在 Python 中的命名</span>
<a name="rest_code_31b1067925774b9fa19b5af40f9992a3-5"></a>    <span class="s">"spam_"</span><span class="p">,</span>
<a name="rest_code_31b1067925774b9fa19b5af40f9992a3-6"></a>    <span class="c1">/// 模块文档，一般留 NULL，而在 pyi 中编写</span>
<a name="rest_code_31b1067925774b9fa19b5af40f9992a3-7"></a>    <span class="nb">NULL</span><span class="p">,</span>
<a name="rest_code_31b1067925774b9fa19b5af40f9992a3-8"></a>    <span class="c1">/// 每个解释器使用该模块的状态尺寸，留 -1 让模块将状态保存在全局变量中</span>
<a name="rest_code_31b1067925774b9fa19b5af40f9992a3-9"></a>    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<a name="rest_code_31b1067925774b9fa19b5af40f9992a3-10"></a>    <span class="c1">/// 模块方法表</span>
<a name="rest_code_31b1067925774b9fa19b5af40f9992a3-11"></a>    <span class="n">SPAM_METHODS</span><span class="p">};</span>
</pre>
<p>将模块定义结构由初始化函数处理，创建一个 Python 的模块对象：</p>
<pre class="code c"><a name="rest_code_3e2a6a4a152345698d792dca2d139679-1"></a><span class="c1">/// 模块初始化函数</span>
<a name="rest_code_3e2a6a4a152345698d792dca2d139679-2"></a><span class="n">PyMODINIT_FUNC</span> <span class="nf">PyInit_spam_</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SPAM_MOD</span><span class="p">);</span> <span class="p">}</span>
</pre>
<p>模块初始化函数的返回值为 <code>PyMODINIT_FUNC</code> ，不接受参数，并且，命名必须为:</p>
<pre class="literal-block">PyInit_&lt;模块名&gt;</pre>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>注意，模块名与以下三个名称相关，需要确保它们相同：</p>
<ul class="simple">
<li><p>在 Python 中 import 的名称（对应模块方法表第二个字段）</p></li>
<li><p>编译产物（动态库）的名称（对应模块方法表第二个字段，编译后不应当修改）</p></li>
<li><p>模块初始化函数的名称（<code>PyInit_&lt;模块名&gt;</code> 模式）</p></li>
</ul>
<p>如果改变了动态库的名称，那么在加载模块时，会寻找另一个名为 <code>PyInit_*</code> 的初始化函数，例如原本名为 <code>spam_.*.pyd</code> ，
之后重命名为 <code>abc.*.pyd</code> 后，导入模块时将会寻找 <code>PyInit_abc</code> 初始化函数。</p>
</div>
<p>现在，补一个 add 函数的定义在下面（功能未实现），先定义为返回 <code>int(0)</code> 以便通过编译，看看效果。</p>
<pre class="code c"><a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-1"></a><span class="c1">// spam_.c</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-2"></a><span class="cp">#define PY_SSIZE_T_CLEAN</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-3"></a><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-4"></a>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-5"></a><span class="c1">/// 将所有传入参数加到一起</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-6"></a><span class="n">PyObject</span> <span class="o">*</span><span class="nf">add</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-7"></a>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-8"></a><span class="c1">/// 模块方法表</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-9"></a><span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">SPAM_METHODS</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-10"></a>    <span class="c1">/// add 方法</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-11"></a>    <span class="p">{</span><span class="s">"add"</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">},</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-12"></a>    <span class="c1">/// 哨兵，必须以它收尾，作用和字符串中的 \0 类似</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-13"></a>    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-14"></a><span class="p">};</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-15"></a>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-16"></a><span class="c1">/// 模块定义结构</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-17"></a><span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">SPAM_MOD</span> <span class="o">=</span> <span class="p">{</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-18"></a>    <span class="c1">/// 模块初始化基对象</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-19"></a>    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-20"></a>    <span class="c1">/// 模块在 Python 中的命名</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-21"></a>    <span class="s">"spam_"</span><span class="p">,</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-22"></a>    <span class="c1">/// 模块文档，一般留 NULL，而在 pyi 中编写</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-23"></a>    <span class="nb">NULL</span><span class="p">,</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-24"></a>    <span class="c1">/// 每个解释器使用该模块的状态尺寸，留 -1 让模块将状态保存在全局变量中</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-25"></a>    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-26"></a>    <span class="c1">/// 模块方法表</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-27"></a>    <span class="n">SPAM_METHODS</span><span class="p">};</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-28"></a>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-29"></a><span class="c1">/// 模块初始化函数</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-30"></a><span class="n">PyMODINIT_FUNC</span> <span class="nf">PyInit_spam_</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SPAM_MOD</span><span class="p">);</span> <span class="p">}</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-31"></a>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-32"></a><span class="n">PyObject</span> <span class="o">*</span><span class="nf">add</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-33"></a>    <span class="k">return</span> <span class="n">PyLong_FromLong</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<a name="rest_code_4fc2dbcfb0d04e438a9fcbb7f02b2470-34"></a><span class="p">}</span>
</pre>
<p>在 <code>spam/__init__.py</code> 中，通过 <code>from .spam_ import *</code> 来导出内容。</p>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id18">试运行</a></h3>
<pre class="code python"><a name="rest_code_b84ae6180b294da6a94e6ffd599f4ea5-1"></a><span class="kn">from</span> <span class="nn">spam</span> <span class="kn">import</span> <span class="n">add</span>
<a name="rest_code_b84ae6180b294da6a94e6ffd599f4ea5-2"></a><span class="k">assert</span> <span class="n">add</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
</pre>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id19">解析位置参数</a></h3>
<p>Python C API 通过 <code>PyArg_ParseTuple</code> 来解析一个元组对象，它接受一个 PyObject* 为第一个参数，
然后是格式化字符串，再之后是一组可写的变量地址，例如：</p>
<pre class="code c"><a name="rest_code_314223bac3ae44769317c9383b1f457c-1"></a><span class="n">PyObject</span> <span class="o">*</span><span class="nf">add</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
<a name="rest_code_314223bac3ae44769317c9383b1f457c-2"></a>    <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_314223bac3ae44769317c9383b1f457c-3"></a>    <span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_314223bac3ae44769317c9383b1f457c-4"></a>    <span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">"ll"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<a name="rest_code_314223bac3ae44769317c9383b1f457c-5"></a>    <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<a name="rest_code_314223bac3ae44769317c9383b1f457c-6"></a>    <span class="k">return</span> <span class="n">PyLong_FromLong</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
<a name="rest_code_314223bac3ae44769317c9383b1f457c-7"></a><span class="p">}</span>
</pre>
<p>这里，Python 与 C 方法参数传递的对应关系为:</p>
<pre class="literal-block"># Python
def add(a, b) -&gt; int:

// C
PyObject *add(PyObject *self, PyObject *args);</pre>
<p>所有位置形参都以 tuple 的形式传递给 args。</p>
<p>这里，列出一些常用的格式字符串 <a class="footnote-reference brackets" href="#doc-fmtstr" id="id10">5</a> ：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead><tr>
<th class="head"><p>格式字符串</p></th>
<th class="head"><p>Python 类型</p></th>
<th class="head"><p>C 类型</p></th>
</tr></thead>
<tbody>
<tr>
<td><p><code>s#</code></p></td>
<td><p>str</p></td>
<td><p>const char* + Py_ssize_t</p></td>
</tr>
<tr>
<td><p><code>y#</code></p></td>
<td><p>bytes</p></td>
<td><p>const char* + Py_ssize_t</p></td>
</tr>
<tr>
<td><p><code>b</code></p></td>
<td><p>int</p></td>
<td><p>unsigned char</p></td>
</tr>
<tr>
<td><p><code>i</code></p></td>
<td><p>int</p></td>
<td><p>int</p></td>
</tr>
<tr>
<td><p><code>I</code></p></td>
<td><p>int</p></td>
<td><p>unsigned int</p></td>
</tr>
<tr>
<td><p><code>l</code></p></td>
<td><p>int</p></td>
<td><p>long int</p></td>
</tr>
<tr>
<td><p><code>k</code></p></td>
<td><p>int</p></td>
<td><p>unsigned long int</p></td>
</tr>
<tr>
<td><p><code>L</code></p></td>
<td><p>int</p></td>
<td><p>long long int</p></td>
</tr>
<tr>
<td><p><code>K</code></p></td>
<td><p>int</p></td>
<td><p>unsigned long long int</p></td>
</tr>
<tr>
<td><p><code>f</code></p></td>
<td><p>float</p></td>
<td><p>float</p></td>
</tr>
<tr>
<td><p><code>d</code></p></td>
<td><p>float</p></td>
<td><p>double</p></td>
</tr>
<tr>
<td><p><code>D</code></p></td>
<td><p>complex</p></td>
<td><p>Py_complex</p></td>
</tr>
<tr>
<td><p><code>O</code></p></td>
<td><p>object</p></td>
<td><p>PyObject*</p></td>
</tr>
<tr>
<td><p><code>p</code></p></td>
<td><p>bool</p></td>
<td><p>int</p></td>
</tr>
<tr>
<td><p><code>(items)</code></p></td>
<td><p>tuple</p></td>
<td><p>...</p></td>
</tr>
</tbody>
</table>
<p>另外，有一些特殊字符：</p>
<dl class="simple">
<dt><code>|</code></dt>
<dd>
<p>剩下的参数是可选参数，在 C 中，这些参数需要初始化一个默认值。</p>
</dd>
<dt><code>$</code></dt>
<dd>
<p>剩下的参数是只能通过命名参数传递的参数。与 <code>|</code> 类似。</p>
</dd>
</dl>
<p>解析 tuple 对象，需要在 <code>()</code> 内填写另外的类型格式字符串:</p>
<pre class="literal-block"># python
test( (1, "a") )

// c
PyArg_ParseTuple(args, "(is)", &amp;num, &amp;str);</pre>
</div>
<div class="section" id="iterator-protocol">
<h3><a class="toc-backref" href="#id20">通过 Iterator Protocol 解析不定参数</a></h3>
<p>在 Python 中，等同于：</p>
<pre class="code python"><a name="rest_code_78150ac647b4431fad2a617961880b9f-1"></a><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
</pre>
<p>在 C 中的等效写法为：</p>
<pre class="code c"><a name="rest_code_67b07e20889e454bacbb8f718d350e13-1"></a><span class="n">PyObject</span> <span class="o">*</span><span class="nf">isum</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-2"></a>    <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-3"></a>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">PyObject_GetIter</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-4"></a>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-5"></a>    <span class="k">while</span> <span class="p">((</span><span class="n">item</span> <span class="o">=</span> <span class="n">PyIter_Next</span><span class="p">(</span><span class="n">iter</span><span class="p">)))</span> <span class="p">{</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-6"></a>        <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="n">PyLong_AsLong</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-7"></a>        <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-8"></a>        <span class="c1">/// 释放 item</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-9"></a>        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-10"></a>    <span class="p">}</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-11"></a>    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-12"></a>    <span class="k">return</span> <span class="n">PyLong_FromLong</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
<a name="rest_code_67b07e20889e454bacbb8f718d350e13-13"></a><span class="p">}</span>
</pre>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id21">解析关键字参数</a></h3>
<pre class="code c"><a name="rest_code_eb43327c82c84656af52952e507623fc-1"></a><span class="c1">/// 在模块方法表中</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-2"></a><span class="p">{</span><span class="s">"named_join"</span><span class="p">,</span> <span class="n">named_join</span><span class="p">,</span> <span class="n">METH_VARARGS</span> <span class="o">|</span> <span class="n">METH_KEYWORDS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">},</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-3"></a>
<a name="rest_code_eb43327c82c84656af52952e507623fc-4"></a><span class="cm">/**</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-5"></a><span class="cm">* def named_join(a=0, b=1, c=2) -&gt; str:</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-6"></a><span class="cm">*/</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-7"></a><span class="n">PyObject</span> <span class="o">*</span><span class="n">named_join</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">)</span> <span class="p">{</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-8"></a>    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kw</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-9"></a>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-10"></a>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-11"></a>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-12"></a>    <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s">"|$III"</span><span class="p">,</span> <span class="n">kw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-13"></a>    <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="k">const</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-14"></a>    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-15"></a>    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-16"></a>    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-17"></a>    <span class="c1">/// 构造时复制</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-18"></a>    <span class="k">const</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">join</span> <span class="o">=</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s">"s#"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">);</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-19"></a>    <span class="n">free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-20"></a>    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">join</span><span class="p">;</span>
<a name="rest_code_eb43327c82c84656af52952e507623fc-21"></a><span class="p">}</span>
</pre>
</div>
</div>
<div class="section" id="python-c">
<h2><a class="toc-backref" href="#id22">Python 与 C 对象的互相转化</a></h2>
<p>Python 提供了一系列命名规律为 <code>Py&lt;Python Type&gt;_From&lt;C Type&gt;</code> 的函数，以便由 C 类型构造 Python 对象。
当然，也有对应的 <code>*As*</code> 函数，将 Python 对象转换成 C 类型。</p>
<p>也可以通过 <code>Py_BuildValue</code> + 格式字符串来由 C 类型转换 Python 对象。</p>
<p>为了 FFI 接口的简洁性，推荐只传递基本类型。</p>
</div>
<div class="section" id="poetry-build">
<h2><a class="toc-backref" href="#id23">将扩展编译过程集成到 poetry build</a></h2>
<p>根据 StackOverflow 上的这个讨论 <a class="footnote-reference brackets" href="#so-poetry-c-ext" id="id12">4</a>。
需要编写一个 build.py 脚本，在其中定义名为 build 的函数，在其中修改 setup 函数的参数即可：</p>
<pre class="code python"><a name="rest_code_8f5d2eda9d1949169009334de9afdad0-1"></a><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">Extension</span>
<a name="rest_code_8f5d2eda9d1949169009334de9afdad0-2"></a><span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">setup_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<a name="rest_code_8f5d2eda9d1949169009334de9afdad0-3"></a>    <span class="n">setup_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
<a name="rest_code_8f5d2eda9d1949169009334de9afdad0-4"></a>        <span class="p">{</span>
<a name="rest_code_8f5d2eda9d1949169009334de9afdad0-5"></a>            <span class="s2">"ext_modules"</span><span class="p">:</span> <span class="p">[</span>
<a name="rest_code_8f5d2eda9d1949169009334de9afdad0-6"></a>                <span class="n">Extension</span><span class="p">(</span><span class="s2">"spam.spam_"</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s2">"spam/spam_.c"</span><span class="p">])</span>
<a name="rest_code_8f5d2eda9d1949169009334de9afdad0-7"></a>            <span class="p">]</span>
<a name="rest_code_8f5d2eda9d1949169009334de9afdad0-8"></a>        <span class="p">}</span>
<a name="rest_code_8f5d2eda9d1949169009334de9afdad0-9"></a>    <span class="p">)</span>
</pre>
<p>为了保持目录结构， Extension 的模块名可以按照 Python 模块导入语法进行命名。
如上， <code>spam.spam_</code> 模块将在 <code>spam/__init__.py</code> 文件中以 <code>from .spam_ import *</code> 的形式将方法暴露出来。</p>
<p>然后，修改 pyproject.toml 中的 bulid 字段：</p>
<pre class="code toml"><a name="rest_code_42a5bd01899f44cd8880bf98298c0b10-1"></a><span class="k">[tool.poetry]</span>
<a name="rest_code_42a5bd01899f44cd8880bf98298c0b10-2"></a><span class="c1"># ... 其他配置</span>
<a name="rest_code_42a5bd01899f44cd8880bf98298c0b10-3"></a><span class="n">build</span> <span class="o">=</span> <span class="s">"build.py"</span>
</pre>
</div>
<div class="section" id="id13">
<h2><a class="toc-backref" href="#id24">添加类型定义</a></h2>
<p>Python 的开发工具，例如 pyls，mypy 等，可以将与模块同级的同名 <code>.pyi</code> 结尾的文件作为类型声明文件，
可以在其中编写类型定义、文档字符串等。</p>
<pre class="code python"><a name="rest_code_b641f266476841d7ae376873d4955224-1"></a><span class="c1"># spam/__init__.pyi</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-2"></a><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-3"></a>    <span class="sd">"""a + b</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-4"></a>
<a name="rest_code_b641f266476841d7ae376873d4955224-5"></a><span class="sd">    &gt;&gt;&gt; add(3, 5)</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-6"></a><span class="sd">    8</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-7"></a><span class="sd">    """</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-8"></a>    <span class="k">pass</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-9"></a><span class="k">def</span> <span class="nf">isum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-10"></a>    <span class="sd">"""传入整数类型的不定参数，将它们加在一起返回</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-11"></a>
<a name="rest_code_b641f266476841d7ae376873d4955224-12"></a><span class="sd">    &gt;&gt;&gt; isum(1, 2, 3)</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-13"></a><span class="sd">    6</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-14"></a><span class="sd">    """</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-15"></a>    <span class="k">pass</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-16"></a><span class="k">def</span> <span class="nf">named_join</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-17"></a>    <span class="sd">"""将 abc 三个字母按传入的数字重复对应次数，组成字符串返回</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-18"></a>
<a name="rest_code_b641f266476841d7ae376873d4955224-19"></a><span class="sd">    &gt;&gt;&gt; named_join(a=1, b=2, c=3)</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-20"></a><span class="sd">    "abbccc"</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-21"></a><span class="sd">    """</span>
<a name="rest_code_b641f266476841d7ae376873d4955224-22"></a>    <span class="k">pass</span>
</pre>
</div>
<div class="section" id="id14">
<h2><a class="toc-backref" href="#id25">参考链接</a></h2>
<dl class="footnote brackets">
<dt class="label" id="doc-ext"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd>
<p><a class="reference external" href="https://docs.python.org/zh-cn/3/extending/index.html">https://docs.python.org/zh-cn/3/extending/index.html</a></p>
</dd>
<dt class="label" id="site-poetry"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd>
<p><a class="reference external" href="https://python-poetry.org/">https://python-poetry.org/</a></p>
</dd>
<dt class="label" id="site-scoop"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd>
<p><a class="reference external" href="https://scoop.sh">https://scoop.sh</a></p>
</dd>
<dt class="label" id="so-poetry-c-ext"><span class="brackets"><a class="fn-backref" href="#id12">4</a></span></dt>
<dd>
<p><a class="reference external" href="https://stackoverflow.com/questions/60073711/how-to-build-c-extensions-via-poetry">https://stackoverflow.com/questions/60073711/how-to-build-c-extensions-via-poetry</a></p>
</dd>
<dt class="label" id="doc-fmtstr"><span class="brackets"><a class="fn-backref" href="#id10">5</a></span></dt>
<dd>
<p><a class="reference external" href="https://docs.python.org/zh-cn/3/c-api/arg.html">https://docs.python.org/zh-cn/3/c-api/arg.html</a></p>
</dd>
</dl>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/c/" rel="tag">c</a></li>
            <li><a class="tag p-category" href="../../../categories/python/" rel="tag">python</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../numeric-caculate-regression-analysis/" rel="prev" title="数值计算：回归分析">上一篇文章</a>
            </li>
            <li class="next">
                <a href="../../2020-06/parallel-job-in-powershell/" rel="next" title="在 PowerShell 中并行执行任务">下一篇文章</a>
            </li>
        </ul></nav></aside><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="autoRenderKatex();"></script><script>
        function autoRenderKatex() {
            renderMathInElement(document.body,
                {
                    
delimiters: [
    {left: "$$", right: "$$", display: true},
    {left: "\\[", right: "\\]", display: true},
    {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
    {left: "\\begin{align*}", right: "\\end{align*}", display: true},
    {left: "$", right: "$", display: false},
    {left: "\\(", right: "\\)", display: false}
]

                }
            );
        }
        </script></article></main><footer id="footer"><p>Contents © 2020 <a href="mailto:zombie110year@outlook.com">Zombie110year</a> - Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a> CC BY-NC-SA 4.0</p>
            
        </footer>
</div>

                <script src="../../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
