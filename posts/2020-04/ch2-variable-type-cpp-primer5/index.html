<!DOCTYPE html>
<html lang="zh_cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>第二章：变量和基本类型 | C++ Primer 5 | ZomHub</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="zh_cn" href="../../../rss.xml">
<link rel="canonical" href="https://blog.zombie110year.top/posts/2020-04/ch2-variable-type-cpp-primer5/">
<link rel="icon" href="../../../favicon.ico" sizes="256x256">
<link rel="icon" href="../../../favicon.png" sizes="512x512">
<meta name="author" content="Zombie110year">
<meta property="og:site_name" content="ZomHub">
<meta property="og:title" content="第二章：变量和基本类型 | C++ Primer 5">
<meta property="og:url" content="https://blog.zombie110year.top/posts/2020-04/ch2-variable-type-cpp-primer5/">
<meta property="og:description" content="目录

指定字面量类型

字符串
整数
浮点数


列表初始化
默认初始化
声明变量
引用：左值引用
指针
const 限定符
const 与引用和指针
constexpr 和常量表达式
处理类型

typedef 与 using
auto 类型自动推导
decltype 计算表达式的类型






指定字面量类型

字符串







前缀
类型
含义



u
char16_t
USC 1">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-04-30T11:35:02+08:00">
<meta property="article:tag" content="c++">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">跳到主内容</a>
    <div id="container">
            <header id="header"><h1 id="brand"><a href="https://blog.zombie110year.top/" title="ZomHub" rel="home">

        <span id="blog-title">ZomHub</span>
    </a></h1>

        
            <nav id="menu"><ul>
<li><a href="../../../archive.html">归档</a></li>
                <li><a href="../../../categories/">标签</a></li>
                <li><a href="../../../rss.xml">订阅</a></li>

    
    
    
    </ul></nav></header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">第二章：变量和基本类型 | C++ Primer 5</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Zombie110year
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2020-04-30T11:35:02+08:00" itemprop="datePublished" title="2020-04-30 11:35">2020-04-30 11:35</time></a>
            </p>
                    <p class="sourceline"><a href="index.rst" class="sourcelink">源文件</a></p>

        </div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<div class="contents topic" id="id1">
<p class="topic-title">目录</p>
<ul class="simple">
<li>
<p><a class="reference internal" href="#id2" id="id13">指定字面量类型</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id14">字符串</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id15">整数</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id16">浮点数</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id6" id="id17">列表初始化</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id18">默认初始化</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id19">声明变量</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id20">引用：左值引用</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id21">指针</a></p></li>
<li><p><a class="reference internal" href="#const" id="id22">const 限定符</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id23">const 与引用和指针</a></p></li>
<li><p><a class="reference internal" href="#constexpr" id="id24">constexpr 和常量表达式</a></p></li>
<li>
<p><a class="reference internal" href="#id12" id="id25">处理类型</a></p>
<ul>
<li><p><a class="reference internal" href="#typedef-using" id="id26">typedef 与 using</a></p></li>
<li><p><a class="reference internal" href="#auto" id="id27">auto 类型自动推导</a></p></li>
<li><p><a class="reference internal" href="#decltype" id="id28">decltype 计算表达式的类型</a></p></li>
</ul>
</li>
</ul>
</div>
<!-- TEASER_END -->
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id13">指定字面量类型</a></h2>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id14">字符串</a></h3>
<table class="colwidths-given">
<colgroup>
<col style="width: 14%">
<col style="width: 29%">
<col style="width: 57%">
</colgroup>
<thead><tr>
<th class="head"><p>前缀</p></th>
<th class="head"><p>类型</p></th>
<th class="head"><p>含义</p></th>
</tr></thead>
<tbody>
<tr>
<td><p>u</p></td>
<td><p>char16_t</p></td>
<td><p>USC 16 编码的字符串</p></td>
</tr>
<tr>
<td><p>U</p></td>
<td><p>char32_t</p></td>
<td><p>USC 32 编码的字符串</p></td>
</tr>
<tr>
<td><p>L</p></td>
<td><p>wchar_t</p></td>
<td><p>宽字符</p></td>
</tr>
<tr>
<td><p>u8</p></td>
<td><p>char</p></td>
<td><p>UTF 8 编码的字符串</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id15">整数</a></h3>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead><tr>
<th class="head"><p>后缀</p></th>
<th class="head"><p>类型</p></th>
<th class="head"><p>含义</p></th>
</tr></thead>
<tbody>
<tr>
<td><p>u,U</p></td>
<td><p>unsigned</p></td>
<td><p>无符号</p></td>
</tr>
<tr>
<td><p>l,L</p></td>
<td><p>long</p></td>
<td><p>加长</p></td>
</tr>
<tr>
<td><p>ll,LL</p></td>
<td><p>long long</p></td>
<td><p>双倍加长</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id16">浮点数</a></h3>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead><tr>
<th class="head"><p>后缀</p></th>
<th class="head"><p>类型</p></th>
<th class="head"><p>含义</p></th>
</tr></thead>
<tbody>
<tr>
<td><p>f,F</p></td>
<td><p>float</p></td>
<td><p>浮点数</p></td>
</tr>
<tr>
<td><p>l,L</p></td>
<td><p>long double</p></td>
<td><p>加长浮点数</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id17">列表初始化</a></h2>
<p>四种初始化形式：</p>
<pre class="code cpp"><a name="rest_code_73ddca05eff342d4a8187de7bcecca0d-1"></a><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_73ddca05eff342d4a8187de7bcecca0d-2"></a><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<a name="rest_code_73ddca05eff342d4a8187de7bcecca0d-3"></a><span class="kt">int</span> <span class="n">x</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<a name="rest_code_73ddca05eff342d4a8187de7bcecca0d-4"></a><span class="kt">int</span> <span class="nf">x</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre>
<p>如果使用列表初始化，提供的初始值存在信息丢失的风险的话，那么编译器将报错。</p>
<dl class="simple">
<dt>使用花括号</dt>
<dd>
<p>如果存在信息丢失风险则报错。</p>
</dd>
<dt>不使用花括号</dt>
<dd>
<p>隐式信息截断。</p>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id18">默认初始化</a></h2>
<p>定义在函数外的变量将被自动初始化为 0，
但定义在函数内的变量 <strong>不会自动初始化</strong>，在初始化它们之前访问它们的值是 <abbr>UB（Undefined Behavior）</abbr>。</p>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id19">声明变量</a></h2>
<pre class="code cpp"><a name="rest_code_7ea2f6d20781492d94230c46926be81d-1"></a><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</pre>
<p>将声明一个名为 <code class="docutils literal">i</code> 的变量，不能初始化，否则将被理解为定义。</p>
<pre class="code cpp"><a name="rest_code_d818463885e34156a62dc39cab93c748-1"></a><span class="c1">// 声明</span>
<a name="rest_code_d818463885e34156a62dc39cab93c748-2"></a><span class="k">extern</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<a name="rest_code_d818463885e34156a62dc39cab93c748-3"></a><span class="c1">// 声明并定义</span>
<a name="rest_code_d818463885e34156a62dc39cab93c748-4"></a><span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<a name="rest_code_d818463885e34156a62dc39cab93c748-5"></a><span class="c1">// 声明并定义并初始化</span>
<a name="rest_code_d818463885e34156a62dc39cab93c748-6"></a><span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="rest_code_d818463885e34156a62dc39cab93c748-7"></a><span class="c1">// 声明并定义并初始化</span>
<a name="rest_code_d818463885e34156a62dc39cab93c748-8"></a><span class="k">extern</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id20">引用：左值引用</a></h2>
<ul class="simple">
<li><p>引用的类型表示法是 <code class="docutils literal">T&amp;</code>，例如 <code class="docutils literal">int</code> -&gt; <code class="docutils literal">int&amp;</code>，<code class="docutils literal">&amp;</code> 在定义时是靠在标识符一侧的；</p></li>
<li><p>引用必须初始化；</p></li>
<li><p>引用的语义为「绑定」而非「拷贝」；</p></li>
<li><p>引用是创建了表示同一值的多个名字，对任何一个引用进行的操作都会影响到目标值。</p></li>
</ul>
<pre class="code cpp"><a name="rest_code_78a0e96e12c34543811a0ba9a7ebaf6b-1"></a><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<a name="rest_code_78a0e96e12c34543811a0ba9a7ebaf6b-2"></a><span class="kt">int</span><span class="o">&amp;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</pre>
<p>在初始化时，如果在同一条语句初始化多个引用，那么 <code class="docutils literal">&amp;</code> 在每个名字前都要出现一次（靠在标识符一侧）：</p>
<pre class="code cpp"><a name="rest_code_501323ab08234966ab13e781980e6e99-1"></a><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// int, int</span>
<a name="rest_code_501323ab08234966ab13e781980e6e99-2"></a><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span> <span class="c1">//int&amp;, int&amp;</span>
<a name="rest_code_501323ab08234966ab13e781980e6e99-3"></a><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">;</span> <span class="c1">// int, int&amp;</span>
</pre>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>引用只在编译期存在？</p>
</div>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id21">指针</a></h2>
<p>指针是一个存储了对象在内存中地址的值。和引用不一样，它可以在不同作用域之间传递、复制，它是一个值，而不是一个名字（符号）。</p>
<ul class="simple">
<li><p>指针的类型表示法是 <code class="docutils literal">T*</code>，例如 <code class="docutils literal">int</code> -&gt; <code class="docutils literal">int *</code>，类似引用，<code class="docutils literal">*</code> 在定义时是靠在标识符一侧的；</p></li>
<li><p>指针可能空悬（指向一个未使用的地址）；</p></li>
<li><p>指针的语义是「指向」而非「存储」；</p></li>
<li><p>可以对右值使用 <code class="docutils literal">&amp;</code> 取地址运算符；</p></li>
<li><p>可以对指针使用 <code class="docutils literal">*</code> 解引用运算符来访问目标地址。</p></li>
</ul>
<pre class="code cpp"><a name="rest_code_1c7b5d8b9af64ab9abd10872ca81a47e-1"></a><span class="kt">int</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// 默认指向 0 指针，这个地址受操作系统保护，无法读写</span>
<a name="rest_code_1c7b5d8b9af64ab9abd10872ca81a47e-2"></a><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<a name="rest_code_1c7b5d8b9af64ab9abd10872ca81a47e-3"></a><span class="kt">int</span><span class="o">*</span> <span class="n">xx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// 指向 x 的地址</span>
</pre>
<pre class="code cpp"><a name="rest_code_823af6c539fd4db88c47df1784b6b47f-1"></a><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_823af6c539fd4db88c47df1784b6b47f-2"></a><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">;</span>
<a name="rest_code_823af6c539fd4db88c47df1784b6b47f-3"></a>
<a name="rest_code_823af6c539fd4db88c47df1784b6b47f-4"></a><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"指针： "</span> <span class="o">&lt;&lt;</span>  <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<a name="rest_code_823af6c539fd4db88c47df1784b6b47f-5"></a><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"数值： "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre>
<p>给指针赋值，语义为修改指针存放的地址，从而指向新的对象。
给指针解引用后赋值，语义为修改指针所指向的对象。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>&amp; * 的上下文相关性</p>
<p><code class="docutils literal">&amp;</code> 和 <code class="docutils literal">*</code> 的含义与它们所处的位置有关：</p>
<pre class="code cpp"><a name="rest_code_c9049cda2bc44bbca194dad02a95a7b5-1"></a><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_c9049cda2bc44bbca194dad02a95a7b5-2"></a><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>     <span class="c1">// &amp; 与类型一起，为声明的一部分，表示引用</span>
<a name="rest_code_c9049cda2bc44bbca194dad02a95a7b5-3"></a><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>         <span class="c1">// * 与类型一起，为声明的一部分，表示指针</span>
<a name="rest_code_c9049cda2bc44bbca194dad02a95a7b5-4"></a><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>         <span class="c1">// &amp; 在表达式中，为运算符，表示取地址</span>
<a name="rest_code_c9049cda2bc44bbca194dad02a95a7b5-5"></a><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>        <span class="c1">// * 在表达式中，为运算符，表示解引用</span>
</pre>
</div>
</div>
<div class="section" id="const">
<h2><a class="toc-backref" href="#id22">const 限定符</a></h2>
<p>const 的作用是告诉编译器，让它禁止对某个变量的修改，
如果在程序中编写了修改被 <cite>const</cite> 修饰的变量，那么就无法通过编译。</p>
<p>这种限制只存在于编译期，如果编写了能在运行期获取对象指针并修改的方法，
那么就可能绕过此限制。不过这种设置都是为了避免一些安全问题，所以不要去卡 BUG。</p>
<dl>
<dt>const 必须初始化</dt>
<dd>
<p>代码中存在未初始化的 const 变量会无法通过编译。</p>
</dd>
<dt>const 不限制读取，可以用来给其他变量赋值</dt>
<dd>
<p>const 只是限制写入。</p>
</dd>
<dt>不同文件的同名 const 对象独立存储</dt>
<dd>
<p>const 值默认在每个文件中独立定义，如果要在多个文件中共享，
须在定义的同时进行 extern 声明：</p>
<pre class="code cpp"><a name="rest_code_621e300f811e459aa17b1fc2faeec190-1"></a><span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre>
</dd>
</dl>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id23">const 与引用和指针</a></h2>
<pre class="code cpp"><a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-1"></a><span class="c1">// const 修饰 int&amp;</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-2"></a><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">;</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-3"></a><span class="c1">//* 和 const int &amp; 表示相同语义</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-4"></a><span class="kt">int</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">;</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-5"></a><span class="c1">//! const 运算符不能修饰 int&amp; 的实例 x</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-6"></a><span class="kt">int</span><span class="o">&amp;</span> <span class="k">const</span> <span class="n">x</span><span class="p">;</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-7"></a><span class="c1">// const 修饰 int*</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-8"></a><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-9"></a><span class="c1">//* 与 const int* 语义相同</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-10"></a><span class="kt">int</span> <span class="k">const</span><span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-11"></a><span class="c1">// const 修饰 x</span>
<a name="rest_code_578dc36c48f44a47bfa8cbd2717f52c6-12"></a><span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">x</span><span class="p">;</span>
</pre>
<dl>
<dt>const 修饰 int&amp;</dt>
<dd>
<p>引用是一个常量，它指向一个确定的对象，但不能修改它。</p>
</dd>
<dt>const 修饰 int*（底层常量）</dt>
<dd>
<p>指针 x 所指向的是一个常量，不能被修改，不过指针本身可以被修改：</p>
<pre class="code cpp"><a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-1"></a><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-2"></a><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-3"></a><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-4"></a>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-5"></a>    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-6"></a>    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-7"></a>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-8"></a>    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">;</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-9"></a>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-10"></a>    <span class="c1">//! 无法通过编译</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-11"></a>    <span class="c1">// *x = m;</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-12"></a>    <span class="c1">// cout &lt;&lt; x &lt;&lt; endl;</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-13"></a>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_555d4d1986f84f99b1dcdf0a8185c639-14"></a><span class="p">}</span>
</pre>
</dd>
<dt>const 修饰 x（顶层常量）</dt>
<dd>
<p>指针本身是一个常量，不可修改，但不限制它修改它所指向的对象（除非它的指向也用 const 修饰）</p>
<pre class="code cpp"><a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-1"></a><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-2"></a><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-3"></a><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-4"></a>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-5"></a>    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-6"></a>    <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-7"></a>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-8"></a>    <span class="c1">//x = &amp;m;</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-9"></a>    <span class="c1">//cout &lt;&lt; x &lt;&lt; endl;</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-10"></a>    <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-11"></a>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-12"></a>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_2ce2e1d6d36d4ca9afb5c694e72a7410-13"></a><span class="p">}</span>
</pre>
</dd>
</dl>
<div class="topic">
<p class="topic-title">顶层常量和底层常量</p>
<dl class="simple">
<dt>顶层</dt>
<dd>
<p>指针本身是一个常量</p>
</dd>
<dt>底层</dt>
<dd>
<p>指针指向的对象是一个常量</p>
</dd>
</dl>
</div>
<p>const 可以用多次，来同时表示顶层和底层常量：</p>
<pre class="code cpp"><a name="rest_code_5bf214391ecf45c180bdd675d798dbaa-1"></a><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre>
</div>
<div class="section" id="constexpr">
<h2><a class="toc-backref" href="#id24">constexpr 和常量表达式</a></h2>
<p>常量表达式的值必须要能在编译期就计算得出，并使用 constexpr 修饰。
和 const 修饰的值相比，常量表达式的检查更严格，不允许使用没有用 const 或 constexpr 修饰，但能够在编译期计算得出的值。</p>
<pre class="code cpp"><a name="rest_code_69512c653a084b0db059ad278455f547-1"></a><span class="c1">// 无法编译</span>
<a name="rest_code_69512c653a084b0db059ad278455f547-2"></a><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="rest_code_69512c653a084b0db059ad278455f547-3"></a><span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<a name="rest_code_69512c653a084b0db059ad278455f547-4"></a><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<a name="rest_code_69512c653a084b0db059ad278455f547-5"></a><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
</pre>
<pre class="code cpp"><a name="rest_code_4dfd6bf25a8b4fda8a588adc5f7e614c-1"></a><span class="c1">// 可以编译</span>
<a name="rest_code_4dfd6bf25a8b4fda8a588adc5f7e614c-2"></a><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="rest_code_4dfd6bf25a8b4fda8a588adc5f7e614c-3"></a><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<a name="rest_code_4dfd6bf25a8b4fda8a588adc5f7e614c-4"></a><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</pre>
<pre class="code cpp"><a name="rest_code_4c14575c2e8c49449955f8d112ac3061-1"></a><span class="c1">// 可以编译</span>
<a name="rest_code_4c14575c2e8c49449955f8d112ac3061-2"></a><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="rest_code_4c14575c2e8c49449955f8d112ac3061-3"></a><span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<a name="rest_code_4c14575c2e8c49449955f8d112ac3061-4"></a><span class="k">constexpr</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</pre>
<p>和 const 修饰符相比，constexpr 用在指针的声明时，只对指针有效，与指针所指的对象无关。</p>
</div>
<div class="section" id="id12">
<h2><a class="toc-backref" href="#id25">处理类型</a></h2>
<div class="section" id="typedef-using">
<h3><a class="toc-backref" href="#id26">typedef 与 using</a></h3>
<dl>
<dt>C 语言中定义类型别名</dt>
<dd><pre class="code c"><a name="rest_code_8efbcc1ebac047438bd624ef6d9441a6-1"></a><span class="k">typedef</span> <span class="p">{</span> <span class="n">old</span> <span class="p">}</span> <span class="p">{</span> <span class="n">new</span> <span class="p">};</span>
</pre></dd>
<dt>C++11 新标准</dt>
<dd><pre class="code cpp"><a name="rest_code_94a05a1088b14581b6af590d89b87ca1-1"></a><span class="k">using</span> <span class="p">{</span> <span class="k">new</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="n">old</span> <span class="p">};</span>
</pre></dd>
</dl>
<p>和旧用法相比，using 更加清晰，例如对数组和指针：</p>
<pre class="code cpp"><a name="rest_code_f068e184f4194e88be228e759ea5c5fc-1"></a><span class="k">typedef</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pstr</span><span class="p">;</span>
<a name="rest_code_f068e184f4194e88be228e759ea5c5fc-2"></a><span class="k">using</span> <span class="n">pstr</span> <span class="o">=</span> <span class="kt">char</span><span class="o">*</span><span class="p">;</span>
<a name="rest_code_f068e184f4194e88be228e759ea5c5fc-3"></a>
<a name="rest_code_f068e184f4194e88be228e759ea5c5fc-4"></a><span class="k">typedef</span> <span class="kt">char</span><span class="o">*</span> <span class="n">astr</span><span class="p">[];</span>
<a name="rest_code_f068e184f4194e88be228e759ea5c5fc-5"></a><span class="k">using</span> <span class="n">astr</span> <span class="o">=</span> <span class="kt">char</span><span class="o">*</span><span class="p">[];</span>
</pre>
<p>以及对函数指针：</p>
<pre class="code cpp"><a name="rest_code_9c3b5bc73d9449e897af94a97145db16-1"></a><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-2"></a><span class="c1">// 将 (int, int) -&gt; int 类型的函数指针命名为 iioi</span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-3"></a><span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="o">*</span><span class="n">iioi</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-4"></a>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-5"></a><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-6"></a>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-7"></a><span class="p">}</span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-8"></a>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-9"></a><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-10"></a>    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-11"></a>    <span class="n">iioi</span> <span class="n">fn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">add</span><span class="p">;</span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-12"></a>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-13"></a>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_9c3b5bc73d9449e897af94a97145db16-14"></a><span class="p">}</span>
</pre>
<p>传统的 typedef 基本上是:</p>
<pre class="literal-block">typedef { 返回值类型 }(* { 新定义的类型名 })({ 形式参数的类型 });</pre>
<pre class="code cpp"><a name="rest_code_ecd723f296424f04bb46c17939e7869d-1"></a><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-2"></a>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-3"></a><span class="k">using</span> <span class="n">iioi</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-4"></a>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-5"></a><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-6"></a>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-7"></a><span class="p">}</span>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-8"></a>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-9"></a><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-10"></a>    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-11"></a>    <span class="n">iioi</span> <span class="n">fn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">add</span><span class="p">;</span>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-12"></a>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-13"></a>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_ecd723f296424f04bb46c17939e7869d-14"></a><span class="p">}</span>
</pre>
<p>把新的类型名后旧的声明放到等号两边，能增加可读性。</p>
</div>
<div class="section" id="auto">
<h3><a class="toc-backref" href="#id27">auto 类型自动推导</a></h3>
<p>auto 声明能根据初始化值自动推导变量类型，存在以下规则：</p>
<ol class="arabic simple">
<li><p>若初始化值为一个引用，那么 auto 将推导为解引用后的类型，<cite>int&amp; -&gt; int</cite>，除非使用 &amp; 修饰 auto，<cite>auto &amp; r = x;</cite>；</p></li>
<li><p>auto 会忽略顶层 const 而保留底层 const，除非用 const 修饰 auto，<cite>const auto x</cite>；</p></li>
</ol>
</div>
<div class="section" id="decltype">
<h3><a class="toc-backref" href="#id28">decltype 计算表达式的类型</a></h3>
<p>auto 用于变量定义，而 decltype 用于计算表达式的类型。
这一个过程发生在编译期：</p>
<pre class="code cpp"><a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-1"></a><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-2"></a><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-3"></a>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-4"></a><span class="p">}</span>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-5"></a><span class="k">using</span> <span class="n">iioi</span> <span class="o">=</span> <span class="k">decltype</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">add</span> <span class="p">);</span>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-6"></a>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-7"></a><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-8"></a>    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-9"></a>    <span class="n">iioi</span> <span class="n">fn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">add</span><span class="p">;</span>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-10"></a>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-11"></a>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_a8d80355dd704b8ebeb9d03faa3e3e7d-12"></a><span class="p">}</span>
</pre>
<p>和 auto 相比， decltype 不会自动解引用。
而且，它处理带括号的表达式时，如果有多余的括号，会将括号处理为引用。</p>
</div>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/c%2B%2B/" rel="tag">c++</a></li>
        </ul></nav></aside><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="autoRenderKatex();"></script><script>
        function autoRenderKatex() {
            renderMathInElement(document.body,
                {
                    
delimiters: [
    {left: "$$", right: "$$", display: true},
    {left: "\\[", right: "\\]", display: true},
    {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
    {left: "\\begin{align*}", right: "\\end{align*}", display: true},
    {left: "$", right: "$", display: false},
    {left: "\\(", right: "\\)", display: false}
]

                }
            );
        }
        </script></article></main><footer id="footer"><p>Contents © 2020 <a href="mailto:zombie110year@outlook.com">Zombie110year</a> - Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a> CC BY-NC-SA 4.0</p>
            
        </footer>
</div>

                <script src="../../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
